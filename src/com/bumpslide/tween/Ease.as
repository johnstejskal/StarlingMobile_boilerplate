/** * This code is part of the Bumpslide Library by David Knape * http://bumpslide.com/ *  * Copyright (c) 2006, 2007, 2008 by Bumpslide, Inc. *  * Released under the open-source MIT license. * http://www.opensource.org/licenses/mit-license.php * see LICENSE.txt for full license terms */ package com.bumpslide.tween {	import com.bumpslide.data.type.RGB;			/**	 * FTween easing functions	 * 	 * Each function takes a current value, a target, the current velocity, 	 * and an object to hold additional named parameters.	 * 	 * The function should return the new velocity/delta.	 * 	 * @author David Knape	 */	public class Ease {				/**		 * Default Ease Out - Nice and Clean		 */		static public function Default ( current:Number, target:Number, veloc:Number, params:Object ) : Number {					return (target-current) * paramValue( params, 'gain', .3);		}				/**		 * Springy Tween		 */		static public function Spring ( current:Number, target:Number, veloc:Number, params:Object) : Number {								// apply gain			veloc += (target-current) * paramValue(params, 'gain', .3);						// apply friction			veloc *= ( 1 - paramValue(params, 'friction', .2) );								return veloc;		}		/**		 * Stuttery motion		 */		static public function Stutter( current:Number, target:Number, veloc:Number, params:Object ) : Number {			return (target-current) * paramValue( params, 'gain', .3) * Math.random();		}				/**		 * Linear Tweening 		 */		static public function Linear ( current:Number, target:Number, veloc:Number, params:Object) : Number {					var d:Number = (target-current);			var speed:Number = paramValue( params, 'speed', 10);			//Debug.trace('speed  = '+speed);			if(d>0) return Math.min( d, speed );			else return Math.max( d, -speed );		}						/**		 * Color Tween - eases R,G,B values inside of Color target		 * 		 * This is kind of a meta-tween.  The actual tweening of the rgb values is		 * specified by the 'subEasing' param.		 */		static public function Color ( current:Number, target:Number, veloc:Number, params:Object ) : Number {										var easeFunction:Function = paramValue( params, 'componentEasing', Ease.Default );									var curr:RGB = RGB.createFromNumber( current );			var targ:RGB = RGB.createFromNumber( target );			var prev:RGB = RGB.createFromNumber( current-veloc ); // previous value in case we are springing												var deltaR:Number = easeFunction.call( null, curr.red, targ.red, curr.red-prev.red, params ); 			var deltaG:Number = easeFunction.call( null, curr.green, targ.green, curr.green-prev.green, params ); 			var deltaB:Number = easeFunction.call( null, curr.blue, targ.blue, curr.blue-prev.blue, params ); 			var newR:Number = curr.red + deltaR;			var newG:Number = curr.green + deltaG;			var newB:Number = curr.blue + deltaB;						// to avoid rounding errors that get us stuck, always round towards the target			newR = deltaR > 0 ? Math.ceil( newR ) : Math.floor( newR );			newG = deltaG > 0 ? Math.ceil( newG ) : Math.floor( newG );			newB = deltaB > 0 ? Math.ceil( newB ) : Math.floor( newB );									var newColor:RGB = new RGB( newR, newG, newB );						//trace( newColor + '/' + targ );									return newColor.number - current;		}				/**		 * Easing capped at a certain velocity		 */		static public function Smooth ( current:Number, target:Number, veloc:Number, params:* ) : Number {					var delta:Number = Ease.Default.apply(null, arguments);			var maxDelta:Number = params[1]!=null ? params[1] : Number.MAX_VALUE; 						if(delta>0) return Math.min( delta, maxDelta );			else return Math.max( delta, -maxDelta );		}		static private function paramValue( params:Object, name:String, defaultValue:* ) : * {			return params[name]!=null ? params[name] : defaultValue;		} 									}}