/** * This code is part of the Bumpslide Library by David Knape * http://bumpslide.com/ *  * Copyright (c) 2006, 2007, 2008 by Bumpslide, Inc. *  * Released under the open-source MIT license. * http://www.opensource.org/licenses/mit-license.php * see LICENSE.txt for full license terms */ package com.bumpslide.ui {	import com.bumpslide.util.Delegate;	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.FocusEvent;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.ui.Keyboard;	import flash.utils.Timer;	/**	 * Base Class for Buttons	 * 	 * This is a generic button with disabled and selected states.	 * By default, setting this class as the base class for your buttons	 * will work as expected if you mark your frames with	 * 'off', 'over', 'down', 'selected', and 'disabled'	 * 	 * Alternatively, you can override the protected display/skin methods:	 * _off, _over, _down, _selected, and _disabled to do what you want.  	 * 	 * @author David Knape	 */	public class Button extends Component {
		static public const OFF:String = 'off';		static public const OVER:String = 'over';		static public const SELECTED:String = 'selected';		static public const DISABLED:String = 'disabled';		static public const DOWN:String = 'down';		public static const EVENT_UPDATE:String = "buttonUpdate";  		protected var _isSelected:Boolean = false;		protected var _isMouseOver:Boolean = false;		protected var _isMouseDown:Boolean = false;		protected var _hasFocus:Boolean = false;  				protected var _focusStateEnabled:Boolean = false;      		protected var _rollOutDelay:Number = 0;        		protected var _rollOutTimer:Timer;		protected var _sendUpdateEvents:Boolean = false;		protected var _toggle:Boolean = false;		protected var _selectOnClick:Boolean = false;
		protected var _buttonState:String = OFF;
		// optional background that is resized to button dimensions		// name your background with this name to use this feature		public var autosize_background:MovieClip;		/**		 * Component initialization (provides initButton hook)		 */		override protected function init():void {			stop();			initButton();							super.init();		}
		/**		 * Initialized button event handlers		 */		protected function initButton():void {						buttonMode = true;			mouseChildren = false;			focusRect = false;						addEventListener(MouseEvent.ROLL_OVER, handleRollOver);        				addEventListener(MouseEvent.ROLL_OUT, handleRollOut);  			addEventListener(MouseEvent.MOUSE_DOWN, handleMouseDown);			addEventListener(MouseEvent.CLICK, handleClick, false, 999);			addEventListener(FocusEvent.FOCUS_IN, handleFocusIn);			addEventListener(FocusEvent.FOCUS_OUT, handleFocusOut);						// render children when they are added (needed for certain frame-based state changes)			addEventListener(Event.ADDED, render);		}
		/**		 * Update the view 		 */		override protected function draw():void {   								if(!enabled) {				_buttonState = Button.DISABLED;				_disabled();			} else if (mousePressed) {				_buttonState = Button.DOWN;				_down();			} else if (selected) {				_buttonState = Button.SELECTED;				_selected();			}  else if (mouseOver || (hasFocus && focusStateEnabled)) {				_buttonState = Button.OVER;				_over();			} else {				_buttonState = Button.OFF;				_off();			}											if(sendUpdateEvents) {				sendEvent(Button.EVENT_UPDATE, buttonState);			}					if(stage) {				stage.addEventListener(Event.RENDER, handleStageRender);				stage.invalidate();			} else {				callLater(50, render);			}			}		private function handleStageRender(e:Event):void {			if(stage) stage.removeEventListener(Event.RENDER, handleStageRender);			render();		}
		/**		 * Render button after frame change		 * 		 * this is where you want to update backgrounds, labels, etc.		 */
		protected function render(event:Event = null):void {			renderBackground();		}				protected function renderBackground():void {			// update background size			if(autosize_background) {				autosize_background.width = width;				autosize_background.height = height;			}			}
		//------------------------------		// PROGRAMMATIC SKIN HOOKS		// - override in subclass		//------------------------------		public function _over():void {			gotoAndStop(OVER);		}
		public function _off():void {			gotoAndStop(OFF);		}
		public function _selected():void {			gotoAndStop(SELECTED);            		}
		public function _disabled():void {			gotoAndStop(DISABLED);		}
		public function _down():void {			gotoAndStop(DOWN);		}
		//-----------------------		// MOUSE EVENT HANDLERS		//-----------------------		protected function handleRollOver( event:MouseEvent = null):void {			Delegate.cancel(_rollOutTimer);			_isMouseOver = true;			invalidate();		}
		protected function handleRollOut( event:MouseEvent = null):void {			_isMouseOver = false;			Delegate.cancel(_rollOutTimer);			if(_rollOutDelay > 0) _rollOutTimer = Delegate.callLater(rollOutDelay, doRollOut);            else doRollOut();            		}
		protected function handleMouseDown(event:MouseEvent = null):void {			_isMouseOver = true;			_isMouseDown = true;			if(stage) stage.addEventListener(MouseEvent.MOUSE_UP, handleMouseUp, false, 0, true);			invalidate();		}
		protected function handleMouseUp(event:MouseEvent = null):void {			_isMouseDown = false;			if(stage) stage.removeEventListener(MouseEvent.MOUSE_UP, handleMouseUp);			invalidate();		}
		protected function handleClick(event:MouseEvent = null):void {			_isMouseDown = false;			if(stage) stage.removeEventListener(MouseEvent.MOUSE_UP, handleMouseUp);			if(toggle) {				selected = !selected;			} else if(selectOnClick) {				selected = true;			}		}		protected function handleFocusIn(event:FocusEvent):void {			_hasFocus = true;			addEventListener(KeyboardEvent.KEY_DOWN, handleKeyPress);			invalidate();		}		protected function handleFocusOut(event:FocusEvent):void {			_hasFocus = false;			addEventListener(KeyboardEvent.KEY_DOWN, handleKeyPress);			invalidate();		}		protected function handleKeyPress(event:KeyboardEvent):void {			if(event.keyCode == Keyboard.ENTER) {				if(toggle) {					selected = !selected;				} else if(selectOnClick) {					selected = true;				}			}		}		protected function doRollOut():void {        				handleMouseUp();			invalidate();		}		//-----------------------------		// GETTERS/SETTERS		//-----------------------------		override public function set enabled( buttonEnabled:Boolean ):void {			if(!buttonEnabled) _isMouseOver = false;  			useHandCursor = buttonEnabled;			mouseEnabled = buttonEnabled;			super.enabled = buttonEnabled;		}
		public function get selected():Boolean {			return _isSelected;		}
		public function set selected(val:Boolean):void {			if(_isSelected == val) return;			_isSelected = val;			_isMouseOver = false;			dispatchEvent(new Event(Event.CHANGE, true));						sendChangeEvent( 'selected', val, !val);					invalidate();		}
		public function get rollOutDelay():Number {			return _rollOutDelay;		}
		public function set rollOutDelay(rollOutDelay:Number):void {			_rollOutDelay = rollOutDelay;		}
		public function get mouseOver():Boolean {			return _isMouseOver;		}
		public function get mousePressed():Boolean {			return _isMouseDown;		}
		public function get sendUpdateEvents():Boolean {			return _sendUpdateEvents;		}
		public function set sendUpdateEvents(val:Boolean):void {			_sendUpdateEvents = val;		}
		public function get buttonState():String {			return _buttonState;		}
		public function get toggle():Boolean {			return _toggle;
		}
		/**		 * toggle selection status when clicked		 */
		public function set toggle(toggle:Boolean):void {			_toggle = toggle;
		}
		public function get selectOnClick():Boolean {			return _selectOnClick;		}
		/**		 * automatically make button selected when it is clicked		 */		public function set selectOnClick(selectOnClick:Boolean):void {			_selectOnClick = selectOnClick;		}		public function get hasFocus():Boolean {			return _hasFocus;		}				/**		 * Whether or not to show overState when focused		 */		public function get focusStateEnabled():Boolean {			return _focusStateEnabled;		}				public function set focusStateEnabled(focusEnabled:Boolean):void {			_focusStateEnabled = focusEnabled;		}	}}