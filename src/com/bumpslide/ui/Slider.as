/** * This code is part of the Bumpslide Library by David Knape * http://bumpslide.com/ *  * Copyright (c) 2006, 2007, 2008 by Bumpslide, Inc. *  * Released under the open-source MIT license. * http://www.opensource.org/licenses/mit-license.php * see LICENSE.txt for full license terms */  package com.bumpslide.ui {	import com.bumpslide.data.type.Padding;	import com.bumpslide.events.DragEvent;	import com.bumpslide.ui.behavior.DragBehavior;	import com.bumpslide.ui.constants.Direction;	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.filters.BevelFilter;	import flash.geom.Rectangle;	/**	 * Base Class for Sliders and Scroll Handles	 * 	 * The basis for this class is the slider component by Keith Peters	 * (com.bit101.components.Slider, version 0.91)	 * 	 * David modified this to make it usable as a scroll bar and changed it	 * to support handle and background assets placed on the stage.	 * 	 * If a 'handle' or 'background' clips are not found, they are drawn 	 * programmatically as in Keith's original component.  If they are found, 	 * we use the x,y position of the handle to determine padding and constraints.	 * 	 * Be sure to uncheck the 'Automatically declare stage instances' option in 	 * your FLA publish settings.  	 * 	 * David's modifications:	 *  - added scrollTarget support	 *  - added handleSize, maxHandlePosition, and handlePosition getters	 *  - refactored event handlers to use these values	 *  - general cleanup and refactoring	 * 	 * Changes:	 * - 2008-11-03 : refactored to use DragBehavior	 * 	 * Released under the open source MIT License	 * http://www.opensource.org/licenses/mit-license.php	 */	public class Slider extends Component {		[Event(name="onSliderChange", type="com.bumpslide.events.UIEvent")]		public static const EVENT_CHANGE:String = "onSliderChange";				// events dispatched by dragBehavior (handle is target)		[Event(name="bumpslideDragStop", type="com.bumpslide.events.DragEvent")]				[Event(name="bumpslideDragMove", type="com.bumpslide.events.DragEvent")]				[Event(name="bumpslideDragStart", type="com.bumpslide.events.DragEvent")]		// optional assets placed on timeline		// comment out if stage instaces are automatically		// declared in FLA publish settings		public var handle:Sprite;		public var background:Sprite;			// options		public var roundResults:Boolean = false;		public var minHandleSize:Number = 16;		public var notifyWhileDragging:Boolean = true;		public var fixedHandleSize:Number = 0;				// private properties		protected var _pad:Padding = new Padding(2);		protected var _value:Number = 0;		protected var _maxValue:Number = 100;		protected var _minValue:Number = 0;		protected var _orientation:String;				protected var _dragBehavior:DragBehavior;		protected var _logarithmic:Boolean = false;				// our scrollable content			protected var _scrollTarget:IScrollable;		/**		 * Constructor		 * @param parent The parent DisplayObjectContainer on which to add this Slider.		 * @param xpos The x position to place this component.		 * @param ypos The y position to place this component.		 * @param defaultHandler The event handling function to handle the default event for this component (change in this case).		 */		public function Slider(orientation:String="horizontal") {				_orientation = orientation;			updateDelay = 0;			//debugEnabled = true;			super();		}		//---------------------		// Overrides		//---------------------				/**		 * Creates and adds the child display objects of this component.		 */		override protected function addChildren():void {						// use timeline assets if found			// draw new ones if necessary			debug('addChildren()');						if(background==null) {				background = new Box(0xbbbbbb,10,10,0,0,4);				background.alpha = .85;				background.filters = [ new BevelFilter(1, 45, 0x000000, .5, 0xffffff, .5, 1.2, 1.2, 1, 2)];				addChild(background);			} 			background.buttonMode = true;						if(handle==null) {				handle = new GenericButton(10, 10, _pad.left, _pad.top);				addChild( handle );			} else {				// act as button				handle.buttonMode = true;				handle.useHandCursor = true;				handle.mouseChildren = false;								// init padding based on position of handle on the stage				_pad = new Padding(handle.y, handle.x, handle.y, handle.x);				if(isVertical) {					_pad.right = _width - handle.getBounds(this).right;				} else {					_pad.bottom = _height - handle.getBounds(this).bottom;				}									// for sliders (not scrollbars), use current handle size as the fixed handle size				fixedHandleSize = ( _orientation == Direction.HORIZONTAL ) ? handle.width : handle.height;			}							// drag using mouse down events from anywhere inside this component			_dragBehavior = DragBehavior.init( handle, null );			addEventListener( DragEvent.EVENT_DRAG_START, handleDragStart ); // mouse down			addEventListener( DragEvent.EVENT_DRAG_MOVE, handleDragMove ); // mouse move			addEventListener( DragEvent.EVENT_DRAG_STOP, handleDragStop ); // mouse up/leave						background.addEventListener( MouseEvent.MOUSE_DOWN, handleBackgroundMouseDown );						// enforce min width at startup			if(_width == 0) _width = 8;		}				/**		 * Draws the visual ui of the component.		 */		override protected function draw():void {			super.draw();						constrainValue();				updateDragBounds();			drawBack();			drawHandle();			positionHandle();					}		//--------------------------		// Helpers		//--------------------------						/**		 * Draws the back of the slider.		 */		protected function drawBack():void {			if(background==null) return;;			background.height = height;			background.width = width;						if(background is Component) Component(background).updateNow();		}		/**		 * Draws the handle of the slider.		 */		protected function drawHandle():void {							if(handle==null) return;				var hs:Number = handleSize;			if(isVertical) {				handle.height = hs;				handle.width = width - _pad.width;			} else {									handle.width = hs;				handle.height = _height - _pad.height;			}			if(handle is Component) {				Component(handle).updateNow();			}		}		/**		 * Adjusts value to be within minimum and maximum.		 */		protected function constrainValue():void {			if (maxValue > minValue) {				_value = Math.max(Math.min(_value, maxValue), minValue);			} else {				_value = Math.max(Math.min(_value, minValue), maxValue);			}		}		/**		 * Adjusts position of handle to match current value		 * 		 * This should be called whenever content, size, or min/max have changed		 */		protected function positionHandle():void {			var pct:Number;						if(logarithmic) {				var loglow:Number = Math.log(minValue);		   		var loghigh:Number = Math.log(maxValue);					pct = (Math.log(value) - loglow) / (loghigh-loglow);			} else { 				pct = (value - minValue) / (maxValue - minValue);			}								handlePosition = Math.round(pct * handleBounds);			if(isVertical) {				handle.x = _pad.left;			} else {				handle.y = _pad.top;			}		}		///////////////////////////////////		// event handlers		///////////////////////////////////				private function handleBackgroundMouseDown(event:MouseEvent):void {						// figure out where we are			var pos:Number = isVertical ? mouseY-_pad.top : mouseX-_pad.left;			var pct:Number = Math.max( 0, Math.min( handleBounds, pos-handleSize/2)) / handleBounds;						if(logarithmic) {				    	var loglow:Number = Math.log(minValue);		   		var loghigh:Number = Math.log(maxValue);						value = Math.exp(pct * (loghigh-loglow) + loglow);			} else {				value = pct * (maxValue - minValue) + minValue;			}									// notify our friends			notifyChanged();						_dragBehavior.startDragging(event);					}						private function handleDragStart(event:DragEvent):void {			// keep bounds updated			updateDragBounds();		}				/**		 * Handles drag start and move events		 */				private function handleDragMove(event:DragEvent):void {		    var pct:Number  = handlePosition/handleBounds;		    		    if(logarithmic) {				    	var loglow:Number = Math.log(minValue);		   		var loghigh:Number = Math.log(maxValue);						value = Math.exp(pct * (loghigh-loglow) + loglow);			} else {				// update value internally (this will place the handle where it needs to be)				value = pct * (maxValue - minValue) + minValue;			}						// notify our friends			notifyChanged();						if(handle is Button) (handle as Button)._over();				}						/**		 * handles drag stop		 */		private function handleDragStop(event:DragEvent):void {			if(handle is Button) (handle as Button)._off();			notifyChanged();		}				/**		 * Updates drag boundary for drag behavior		 */		protected function updateDragBounds():void {			// update drag bounds			_dragBehavior.dragBounds = new Rectangle(_pad.left, _pad.top, handleBounds, 0);			if(isVertical) {				_dragBehavior.dragBounds.height = handleBounds;				_dragBehavior.dragBounds.width = 0;			}				}				/**		 * Dispatches a Change event		 */		protected function notifyChanged():void {			debug('notifyChanged() value = ' + value);			if(!isDragging || notifyWhileDragging) sendEvent(EVENT_CHANGE, value);			if(scrollTarget) scrollTarget.scrollPosition = value;		}		///////////////////////////////////		// getter/setters		///////////////////////////////////		/**		 * Sets / gets the current value of this slider.		 */		public function set value(v:Number):void {				if(isNaN(v)) v=0;			_value = v;			constrainValue();			drawHandle();			positionHandle();		}		public function get value():Number {			if(roundResults) return Math.round(_value);			else return _value;		}		/**		 * Gets / sets the maximum value of this slider.		 */		public function set maxValue(m:Number):void {			_maxValue = m;			constrainValue();			positionHandle();		}		public function get maxValue():Number {			if(scrollTarget) return scrollTarget.totalSize - scrollTarget.visibleSize;			else return _maxValue;		}		/**		 * Gets / sets the minimum value of this slider.		 */		public function set minValue(m:Number):void {			_minValue = m;			constrainValue();			positionHandle();		}		public function get minValue():Number {			return _minValue;		}		/**		 * Handle length for vertical, width for horizontal		 */		public function get handleSize():Number {			if(scrollTarget != null) {				var total_size:Number = scrollTarget.totalSize;				if(total_size==0 || isNaN(total_size)) total_size=.00001;				var bgSize:Number = (!isVertical) ? width - _pad.width : height - _pad.height;				var size:Number = scrollTarget.visibleSize / total_size * bgSize;						return Math.round( Math.min(bgSize, Math.max(size, minHandleSize)) );			} else {				if(fixedHandleSize > 0) return fixedHandleSize;				else return (!isVertical) ? height - _pad.height : width - _pad.width;			}		}		/**		 * Shortcut for handlePosition after accomodating padding		 */		public function get handlePosition():Number {			return (isVertical) ? handle.y - _pad.top : handle.x - _pad.left ; 		}			/**		 * Sets handle position and adds padding		 */		public function set handlePosition( n:Number ):void {			if(!isVertical) {				handle.x = n + _pad.left;			} else {				handle.y = n + _pad.top;			}		}		/**		 * Shortcut for handle bounds rect length		 */		public function get handleBounds():Number {			return ((!isVertical) ? width - _pad.width : height - _pad.height) - handleSize; 		}		/**		 * scrollable content		 */		public function get scrollTarget():IScrollable {			return _scrollTarget;		}		/**		 * Makes slider a scroll handle by assigning scrollable content		 */		public function set scrollTarget( scrollContent:IScrollable ):void {						_scrollTarget = scrollContent;						maxValue = scrollContent.totalSize - scrollContent.visibleSize;			value = 0;			invalidate();		}		public function get isDragging() : Boolean {			return _dragBehavior.isDragging;		}				public function get isVertical() : Boolean {			return orientation==Direction.VERTICAL;		}		/**		 * Convenience method to set the three main parameters in one shot.		 * @param min The minimum value of the slider.		 * @param max The maximum value of the slider.		 * @param value The value of the slider.		 */		public function setSliderParams(min:Number, max:Number, val:Number):void {			this.minValue = min;			this.maxValue = max;			this.value = val;		}		override public function toString():String {			return "[Slider]";		}				public function get orientation():String {			return _orientation;		}				public function set orientation(orientation:String):void {			_orientation = orientation;			invalidate();		}				public function get logarithmic():Boolean {			return _logarithmic;		}				public function set logarithmic(logarithmic:Boolean):void {			_logarithmic = logarithmic;			invalidate();		}	}}