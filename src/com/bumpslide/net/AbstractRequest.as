package com.bumpslide.net {	import flash.events.ErrorEvent;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.utils.getTimer;	// Request complete event	[Event(name='complete',type='flash.events.Event')]		// Request cancelled	[Event(name='cancel',type='flash.events.Event')]		// Error event	[Event(name='error',type='flash.events.ErrorEvent')]			/**	 * Generic async request, provides retry and timeout functionality as well as a responder implementation	 * 	 * @author David Knape	 */	public class AbstractRequest extends EventDispatcher implements IRequest 	{		// Error Messages		public static var ERROR_TIMED_OUT:String = "Request Timed Out";		public static var ERROR_SECURITY:String = "Security Error";		public static var ERROR_DEFAULT:String = "Unknown HTTP Error";		public static var ERROR_IO:String = "I/O Error";		public static var ERROR_CANCELLED:String = "Request Cancelled";		// options		public var debugEnabled:Boolean = false;		// private					// responders		protected var _responders:Array;		// timeout timer		protected var _loadTimer:Timer;		// timeout per request (in seconds)		protected var _timeout:uint = 30;		// number of times to retry		protected var _retryCount:uint = 3;		// parsed/formatted results		protected var _result:*;		// raw data		protected var _data:*;				// are we actively loading		protected var _loading:Boolean = false;						/**		 * Creates a new HTTPRequest that wraps a URLRequest		 */		public function AbstractRequest( responder:IResponder = null ) 		{				if(responder != null) addResponder(responder);		}				/**		 * Adds a responder to the request		 */		public function addResponder( responder:IResponder ):void 		{			if(_responders == null) _responders = new Array();			if(responder != null)	_responders.push(responder);		}   				/**		 * Starts loading the request		 */		public function load():void 		{						if(loading) return;			initTimer();			initRequest();		}				/**		 * Cancels pending request		 */		public function cancel():void 		{				raiseError(ERROR_CANCELLED);			dispatchEvent( new Event( Event.CANCEL ) );		}				/**		 * Starts listening to load events and start the loading process		 */			protected function initRequest():void 		{			throw new Error('initRequest() must be implemented in a subclass');		}				/**		 * closes the URLLoader and stops listening to URLLoader events		 */		protected function killRequest():void 		{				throw new Error('initRequest() must be implemented in a subclass');		}				/**		 * Kills the request, processes result, and triggers complete event		 * 		 * This should be called from an onComplete handler and passed some raw data to process		 * 		 */		protected function finishCompletedRequest(rawData:*):void 		{			debug('Complete');						killRequest();				killTimer();										// save raw data			_data = rawData;			            			// process the data into some kind of 'result'			_result = getResult();            			// pass data to responders			for each (var r:IResponder in _responders) {				if(r.fault != null) r.result(result);			}						// dispatch the complete event			dispatchEvent(new Event(Event.COMPLETE));		}				/**		 * This should be overrided by subclasses to parse XML, JSON, etc.		 * 		 * By default, we just set the result to be the raw data		 */		protected function getResult():* 		{			return data;		}								/**		 * Starts the timer that is used to manage timeouts and retries		 */		protected function initTimer():void 		{			_loadTimer = new Timer(timeout * 1000, retryCount);			_loadTimer.addEventListener(TimerEvent.TIMER, handleTimeout);			_loadTimer.addEventListener(TimerEvent.TIMER_COMPLETE, handleFinalTimeout);			_loadTimer.start();		}				/**		 * Stops the timer used to manage timeouts and retries		 */		protected function killTimer():void 		{			if(_loadTimer == null) return;			_loadTimer.stop();			_loadTimer.removeEventListener(TimerEvent.TIMER, handleTimeout);			_loadTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, handleFinalTimeout);		}				/**		 * After request times out, try again		 */		protected function handleTimeout(e:TimerEvent = null):void 		{			debug('retrying (time: ' + getTimer() + ')');			killRequest();			initRequest();		}				/**		 * If Timer has expired, we have completed all retries.  Kill it.		 */		private function handleFinalTimeout(event:TimerEvent):void 		{			debug('final try timed out (time: ' + getTimer() + ')');			killRequest();			raiseError(ERROR_TIMED_OUT);		}				/**		 * calls fault handler on responder and traces error message		 */		protected function raiseError( msg:String = "" ):void 		{			if(msg == "") msg = ERROR_DEFAULT;						killRequest();				killTimer();						debug('Error: ' + msg);			// pass message to responder fault handlers			for each (var r:IResponder in _responders) {				if(r.fault != null) r.fault(msg);			}						if(msg!=ERROR_CANCELLED) {				dispatchEvent( new ErrorEvent( ErrorEvent.ERROR, false, false, msg ));			}		}				/**		 * trace util		 */		protected function debug(msg:*):void 		{			if(debugEnabled) trace(this.toString() + msg);		}				override public function toString():String 		{			return '[Request] ';		}				/**		 * Timeout in seconds		 */		public function get timeout():uint {			return _timeout;		}				public function set timeout(seconds:uint):void {			_timeout = seconds;		}				/**		 * Number of times to retry request if it is timing out		 */		public function get retryCount():uint {			return _retryCount;		}				public function set retryCount(n:uint):void {			_retryCount = n;		}				/**		 * Access to a formatted result object (XML, decoded JSON, etc. - depends on implementation)		 * 		 * This is what gets passed to the responder's result handler		 */		public function get result():* {			return _result;		}				/**		 * The raw data retrieved from the server		 */		public function get data():* {			return _data;		}				/**		 * Are we loading?		 */		public function get loading():Boolean {			return _loadTimer!=null && _loadTimer.running;		}			}}