/** * This code is part of the Bumpslide Library by David Knape * http://bumpslide.com/ *  * Copyright (c) 2006, 2007, 2008 by Bumpslide, Inc. *  * Released under the open-source MIT license. * http://www.opensource.org/licenses/mit-license.php * see LICENSE.txt for full license terms */package com.bumpslide.net.deprecated {        import flash.events.*;    import flash.net.URLRequest;    import flash.utils.Timer;    import flash.net.URLLoader;                /**    * Enqueues URLLoader requests    *     * Note: This class is on it's way to being deprecated.      * The HTTPRequest class should probably be used instead.    * If you need a queue, you can sequence with a CommandQueue    * or make your own action queue.    *     * - uses weak references for all event listeners    * - provides loading queue    * - handles timeouts and retries    *     * @author David Knape    */    public class URLLoaderQueue extends EventDispatcher {                public var logEnabled:Boolean = false;                // the queue of URLLoadRequest objects        protected var loaderQueue:Array;                // the currently loading URLLoadRequest        protected var activeLoader:URLLoadRequest;                // time to wait before calling timeout handler        protected var __timeoutSeconds:int = 30;                 // number of retries, set to 0 to never retry          protected var __numRetries:int = 2;                       // retry timer and counter        private var retryTimer:Timer;        private var retryCount:int = 0;                public function URLLoaderQueue(timeoutSeconds:int=30, numRetries:int=2) {        	        	timeoutSeconds = timeoutSeconds;        	numRetries = numRetries;        	            init();            clearAll();        }                private function init() : void {            retryTimer = new Timer( timeoutSeconds*1000, 1);            retryTimer.addEventListener(TimerEvent.TIMER, handleTimeout );        }            /**         * Clears pending requests         */        public function clearAll() : void {            log( 'clearing all pending requests');            loaderQueue = new Array();                      if(activeLoader!=null) {                activeLoader.cancel();            }                        // reset timer            retryTimer.reset();            retryCount = 0;            activeLoader = null;        }                /**         * Cancel active URL Request         */        public function cancelActiveLoader():void        {            try {                   activeLoader.cancel();             } catch (e:Error) {                 // active loader is null or does not have open connection             }            activeLoader = null;            loadNext();        }                public function get busy () : Boolean {            return activeLoader!=null;        }                /**         * Enqueue a URL request         */        public function enqueueRequest( req:URLRequest, callback:Function=null, inputArgs:Array=null ):URLLoadRequest        {        	var pendingRequest:URLLoadRequest = new URLLoadRequest( getURLLoader(), req, callback, inputArgs );        	                        log('ENQUEUED '+pendingRequest); // for '+req.url);            loaderQueue.push( pendingRequest );                      if(activeLoader==null) loadNext();            return pendingRequest;        }                       /**         * returns true if we are retrying, false if that was the last time         */         protected function retry():Boolean         {                       if(retryCount<numRetries) {                log('Retrying to load '+activeLoader );                           retryCount++;                                // close pending request                activeLoader.cancel();                activeLoader.load();                retryTimer.reset();                retryTimer.start();                return true;            } else {                handleError('timed out');                cancelActiveLoader();                return false;            }        }                  /**         * Load the next item in the queue or finish         */              protected function loadNext():Boolean         {                       retryTimer.reset();            retryCount = 0;                        activeLoader = loaderQueue.shift() as URLLoadRequest;            if(activeLoader!=null) {                log('LOADING '+activeLoader);                activeLoader.load();                retryTimer.start();                return true;            } else {                log('ALL DONE - Load queue is now empty');                 return false;            }        }        /**         * on timeout, retry         */        protected function handleTimeout(e:TimerEvent=null) : void {            log('TIMED OUT on try '+retryCount+'  -- Retries=' + __numRetries);            retry();        }                        /**         * shortcut to get URLLoader with all the default listeners in place         */        protected function getURLLoader():URLLoader        {            var loader:URLLoader = new URLLoader();                loader.addEventListener("progress", onProgress, false, 0, true);                loader.addEventListener("ioError", onIOError, false, 0, true);                loader.addEventListener("securityError", onSecurityError, false, 0, true);                   loader.addEventListener("complete", onComplete, false, 0, true);                    loader.addEventListener(HTTPStatusEvent.HTTP_STATUS, onStatus, false, 0, true);               return loader;                  }                               //-------------------------        // Loader Event Handlers        //-------------------------                protected function onIOError(event:IOErrorEvent):void        {            log('I/O ERROR while loading '+activeLoader+ ' ' + event.text);            handleError( "HTTP Error (status "+activeLoader.httpStatus+")");            	           	cancelActiveLoader();            loadNext();        }                     protected function onStatus(event:HTTPStatusEvent):void        {			activeLoader.httpStatus = event.status;			//log('HTTP Status ' + event.status );        }                         protected function onSecurityError(event:SecurityErrorEvent):void        {            log('SECURITY ERROR while loading '+activeLoader);            handleError( "Security Error" );            loadNext();        }                   protected function onProgress(event:ProgressEvent):void        {            //log('PROGRESS: '+ Math.floor( activeLoader.percentLoaded * 100) + '%');            dispatchEvent( new URLEvent( URLEvent.PROGRESS, activeLoader.urlRequest.url, null, null, '', activeLoader.percentLoaded) );          }                protected function onComplete(event:Event):void        {            log('COMPLETE '+activeLoader);            if(activeLoader.callback!=null) {                try {                	// try callback with data and params                    activeLoader.callback.call( this, event.target.data, activeLoader.data );                } catch (ae:ArgumentError ) {                 	// try just with data                	activeLoader.callback.call( this, event.target.data );                } catch (e:Error) {                    trace('[URLLoaderQueue] Encountered error calling onComplete handler: ' + e.message);                    trace(e.getStackTrace());                    handleError( e.message );                }            }            dispatchEvent( new URLEvent( URLEvent.COMPLETE, activeLoader.urlRequest.url, event.target.data, activeLoader.data)  );            loadNext();        }                protected function handleError( msg:String="Unknown Error" ) : void {            log('ERROR: ' + msg );               dispatchEvent( new URLEvent( URLEvent.ERROR, activeLoader.urlRequest.url, null, activeLoader.data, msg)  );          }                protected function log( s:String ) : void {            if(logEnabled) trace('[URLLoaderQueue] ' + s);		}
		
		public function get timeoutSeconds():int {			return __timeoutSeconds;
		}
		
		public function set timeoutSeconds(timeoutSeconds:int):void {			this.__timeoutSeconds = timeoutSeconds;			retryTimer.delay = __timeoutSeconds * 1000;
		}				public function get numRetries():int {			return __numRetries;		}				public function set numRetries(numRetries:int):void {			this.__numRetries = numRetries;		}	}}