package com.thirdsense.animation 
{
	import flash.display.BitmapData;
	import flash.display3D.Context3DProfile;
	import flash.geom.Point;
	import flash.geom.Rectangle;
	import starling.core.Starling;
	import starling.utils.getNextPowerOfTwo;
	
	/**
	 * Class to enable consolidation of SpriteSequence objects in to a single size optimized spritesheet for use with Starling
	 * @author Ben Leffler
	 */
	
	public class SpriteSheetHelper 
	{
		/**
		 * Resulting spritesheet generated by the consolidateSprites static function
		 */
		public var spritesheet:BitmapData;
		
		/**
		 * Resulting sparrow xml generated by the consolidateSprites static function
		 */
		public var sparrow_xml:XML;
		
		/**
		 * The pool name of the object
		 */
		public var pool:String;
		
		/**
		 * Vector of participating SpriteSequence objects
		 */
		public var sprite_sequences:Vector.<SpriteSequence>;
		
		/**
		 * constructor
		 */
		public function SpriteSheetHelper() 
		{
			
		}
		
		/**
		 * Obtains an array of the available sequence names contained within the helper object
		 */
		
		public function get sequences():Array
		{
			var arr:Array = new Array();
			for ( var i:uint = 0; i < this.sprite_sequences.length; i++ )
			{
				arr.push( this.sprite_sequences[i].sequence );
			}
			return arr;
		}
		
		/**
		 * Obtains the offset point associated with a specific SpriteSequence contained within the helper
		 * @param	sequence_name	The name of the sequence to obtain an offset for
		 * @return	Point representation of the offset
		 */
		
		public function getOffset( sequence_name:String ):Point
		{
			for ( var i:uint = 0; i < this.sprite_sequences.length; i++ )
			{
				if ( this.sprite_sequences[i].sequence == sequence_name )
				{
					return this.sprite_sequences[i].cell_offset;
				}
			}
			
			return null;
		}
		
		/**
		 * Disposes BitmapData objects contained within associated SpriteSequences and the resulting spritesheet object
		 * @param	sprite_sequences	Disposes the sprite sequences used to comprise the Helper
		 * @param	spritesheet	Disposes the resulting spritesheet object
		 */
		
		public function dispose( sprite_sequences:Boolean = true, spritesheet:Boolean = true ):void
		{
			if ( sprite_sequences && this.sprite_sequences && this.sprite_sequences.length )
			{
				for ( var i:uint = 0; i < this.sprite_sequences.length; i++ )
				{
					this.sprite_sequences[i].dispose();
				}
			}
			
			if ( this.spritesheet && spritesheet )
			{
				this.spritesheet.dispose();
				this.spritesheet = null;
			}
		}
		
		/**
		 * Adds sprite sequences to the helper object and regenerates the spritesheet with the new images
		 * @param	new_sequences	An array of the new SpriteSequence objects to add to the helper
		 * @return	Boolean value indicating the success of the add
		 */
		
		public function addSpriteSequences( new_sequences:Array ):Boolean
		{
			var len:int = new_sequences.length;
			for ( var i:uint = 0; i < len; i++ )
			{
				if ( this.sprite_sequences.indexOf(new_sequences[i]) >= 0 )
				{
					trace( "SpriteSheetHelper :: Failed to add SpriteSequence to helper as it already exists in this helper object" );
					return false;
				}
			}
			
			consolidateSprites( new_sequences, this );
			
			return true;
		}
		
		/**
		 * Removes sprite sequences from the helper object.
		 * @param	sequence_names	An array of the sequence names used for each individual child of the helper
		 * @param	dispose	Pass as true if the removal of the sprite sequence also triggers a disposal of the child
		 */
		
		public function removeSpriteSequences( sequence_names:Array, dispose:Boolean = true ):void
		{
			var len:int = this.sprite_sequences.length;
			var len2:int = sequence_names.length;
			for ( var j:uint = 0; j < len2; j++ )
			{
				for ( var i:uint = 0; i < len; i++ )
				{
					if ( this.sprite_sequences[i].sequence == sequence_names[j] )
					{
						if ( dispose ) this.sprite_sequences[i].dispose();
						this.sprite_sequences.splice( i, 1 );
						i--;
						len--;
					}
				}
			}
		}
		
		/**
		 * A non-optimized arrangement algorithm that sorts from largest area to smallest area and places in a scanline sequence over multiple rows
		 * @param	rects	The vector of rectangles to arrange.
		 * @return	An array that consists of the area's maximum width and height [max_width, max_height];
		 */
		
		static public function greedyArrange( rects:Vector.<Rectangle> ):Array
		{
			var t:Number = new Date().getTime();
			
			var rectangles:Vector.<Rectangle> = new Vector.<Rectangle>;
			var max_width:Number = 0;
			var max_height:Number = 0;
			for ( var k:uint = 0; k < rects.length; k++ )
			{
				rectangles.push( rects[k] );
				if ( max_width < rects[k].width ) max_width = rects[k].width;
				if ( max_height < rects[k].height ) max_height = rects[k].height;
			}
			rectangles.sort( sortFn );
			
			var success:Boolean = false;
			var pw2:int = getNextPowerOfTwo( Math.max(max_height, max_width) );
			
			var len:int = rectangles.length;
			
			while ( !success )
			{
				var lh:Number = 0;
				for ( var i:uint = 0; i < len; i++ )
				{
					if ( i )
					{
						rectangles[i].x = rectangles[i - 1].x + rectangles[i - 1].width + 1;
						rectangles[i].y = rectangles[i - 1].y;
						if ( rectangles[i].height > lh )
						{
							lh = rectangles[i].height;
						}
					}
					else
					{
						rectangles[i].x = rectangles[i].y = 0;
						lh = rectangles[i].height;
					}
					
					if ( rectangles[i].x + rectangles[i].width > pw2 )
					{
						rectangles[i].x = 0;
						rectangles[i].y = rectangles[i - 1].y + lh + 1;
						lh = rectangles[i].height;
					}
					if ( rectangles[i].y + lh > pw2 )
					{
						pw2 = getNextPowerOfTwo( pw2 + 1 );
						break;
					}
					else if ( i == len - 1 )
					{
						success = true;
					}
				}
				
			}
			
			max_height = 0;
			max_width = 0;
			for ( i = 0; i < len; i++ )
			{
				if ( rectangles[i].x + rectangles[i].width > max_width )
				{
					max_width = rectangles[i].x + rectangles[i].width;
				}
				if ( rectangles[i].y + rectangles[i].height > max_height )
				{
					max_height = rectangles[i].y + rectangles[i].height;
				}
			}
			
			//trace( "Time taken " + (new Date().getTime() - t) + "ms" );
			//trace( "Helper dimensions: " + max_width + " x " + max_height );
			
			return [ Math.ceil(max_width), Math.ceil(max_height) ];
		}
		
		/**
		 * Arranges a vector of rectangle objects in to an optimal format that adheres to a Base-2 spritesheet layout
		 * @param	rects	An array of Rectangles to be arranged. The objects contained within will be directly translated.
		 * @return	The optimal base-2 value the arrangement has configured (Array: [width][height])
		 */
		
		static public function arrange( rects:Vector.<Rectangle> ):Array
		{
			// As per Richard E. Korf's paper: Optimal Rectangle Packing: Initial Results - http://www.aaai.org/Papers/ICAPS/2003/ICAPS03-029.pdf
			// 1
			var t:Number = new Date().getTime();
			// clone the rectangle vector and sort in order of area (large > small). Also figure out the largest dimensions of a single rect
			var rectangles:Vector.<Rectangle> = new Vector.<Rectangle>;
			var max_width:Number = 0;
			var max_height:Number = 0;
			for ( var k:uint = 0; k < rects.length; k++ )
			{
				rectangles.push( rects[k] );
				if ( max_width < rects[k].width ) max_width = rects[k].width;
				if ( max_height < rects[k].height ) max_height = rects[k].height;
			}
			rectangles.sort( sortFn );
			
			// 3
			// staring with an area of Base2 area of the maximum width or height (whatever is larget), tries to fit all
			// rectangles within said area. When it fails, increase the area by next power of two... and so on until all rectangles fit
			var success:Boolean = false;
			var pw2:int = getNextPowerOfTwo( Math.max(max_height, max_width) );
			pw2 = 4096;
			
			while ( !success )
			{
				success = true;
				
				var envelope:Rectangle = new Rectangle( 0, 0, pw2, pw2 );
				var placed:Boolean = false;
				
				// REDUNDANT AS MAX WIDTH/MAX HEIGHT REFACTORED PRE LOOP
				// first check if all rectangles don't exceed the envelope area. If so, instant fail then on to next power of two size up
				/*var len:int = rectangles.length;
				for ( var i:uint = 0; i < len; i++ )
				{
					if ( rectangles[i].width > pw2 || rectangles[i].height > pw2 )
					{
						success = false;
						break;
					}
				}*/
				
				// Each rectangle can individually fit in the envelope. Now try to arrange ALL rectangles to fit within the envelope, whilst
				// not overlapping with each other.
				var len:int = rectangles.length;
				
				if ( success )
				{
					for ( var i:uint = 0; i < len; i++ )
					{
						// Checks EVERY pixel position in the envelope for a fit
						
						var lim_x:Number = pw2 - rectangles[i].width;
						var lim_y:Number = pw2 - rectangles[i].height;
						
						for ( var x1:int = 0; x1 <= lim_x; x1 += 50 )
						{
							placed = false;
							
							for ( var y1:int = 0; y1 <= lim_y; y1 += 50 )
							{
								rectangles[i].x = x1;
								rectangles[i].y = y1;
								
								// check collision with other rectangles. If colliding, break and try the next pixel position
								var collides:Boolean = false;
								for ( var j:uint = 0; j < i; j++ )
								{
									if ( rectangles[i].intersects(rectangles[j]) )
									{
										collides = true;
									}
								}
								
								// The rectangle doesn't collide with others, so check if it is within the bounds of the envelope area
								if ( !collides && envelope.containsRect(rectangles[i]) )
								{
									placed = true;
									break;
								}
							}
							
							if ( placed )
							{
								break;
							}
						}
						
						
						if ( !placed )
						{
							success = false;
							break;
						}
					}
				}
				
				if ( !success ) pw2 = getNextPowerOfTwo( pw2 + 1 );				
			}
			
			max_height = 0;
			max_width = 0;
			for ( i = 0; i < len; i++ )
			{
				if ( rectangles[i].x + rectangles[i].width > max_width )
				{
					max_width = rectangles[i].x + rectangles[i].width;
				}
				if ( rectangles[i].y + rectangles[i].height > max_height )
				{
					max_height = rectangles[i].y + rectangles[i].height;
				}
			}
			
			trace( "Time taken " + (new Date().getTime() - t) + "ms" );
			trace( "Helper dimensions: " + max_width + " x " + max_height );
			
			return [ Math.ceil(max_width), Math.ceil(max_height) ];
			
		}
		
		/**
		 * @private	Sorts based on a criteria of rectangle area and then rectangle width
		 * @param	rect1
		 * @param	rect2
		 * @return
		 */
		
		static private function sortFn( rect1:Rectangle, rect2:Rectangle ):int
		{
			if ( rect1.width * rect1.height > rect2.width * rect2.height ) return -1;
			if ( rect1.width * rect1.height < rect2.width * rect2.height ) return 1;
			
			if ( rect1.width > rect2.width ) return -1;
			if ( rect1.width < rect2.width ) return 1;
			
			return 0;
		}
		
		/**
		 * Takes an array of SpriteSequence objects, packages them up and creates a SpriteSheetHelper object for optimized use in Starling
		 * @param	sequences	An array of SpriteSequence objects. These objects should have a common pool parameter and contain unique sequence names for identification purposes
		 * @return	A new SpriteSheetHelper object for use with the LaunchPad TexturePack class
		 */
		
		static public function consolidateSprites( sequences:Array, helper:SpriteSheetHelper = null ):SpriteSheetHelper
		{
			if ( helper )
			{
				for ( var k:uint = 0; k < helper.sprite_sequences.length; k++ )
				{
					sequences.push( helper.sprite_sequences[k] );
				}
				helper.dispose( false, true );
			}
			
			var len:int = sequences.length;
			var rects:Vector.<Rectangle> = new Vector.<Rectangle>;
			var bmds:Vector.<BitmapData> = new Vector.<BitmapData>;
			var names:Array = new Array();
			var offsets:Object = new Object();
			
			for ( var i:uint = 0; i < len; i++ )
			{
				var ss:SpriteSequence = sequences[i];
				for ( var j:uint = 0; j < ss.sprites.length; j++ )
				{
					rects.push( ss.sprites[j].rect );
					bmds.push( ss.sprites[j] );
					names.push( ss.sequence );
				}
				offsets[ ss.sequence ] = ss.cell_offset;
			}
			
			var pw2:Array = greedyArrange( rects );
			
			var sheet:BitmapData = new BitmapData( pw2[0], pw2[1], true, 0 );
			var pt:Point = new Point();
			len = rects.length;
			for ( i = 0; i < len; i++ )
			{
				pt.x = rects[i].x;
				pt.y = rects[i].y;
				sheet.copyPixels( bmds[i], bmds[i].rect, pt, null, null, true );
			}
			
			if ( !helper )
			{
				helper = new SpriteSheetHelper();
				helper.pool = sequences[0].pool;
				helper.sprite_sequences = new Vector.<SpriteSequence>;
			}
			helper.spritesheet = sheet;
			sheet = null;
			
			for ( i = 0; i < sequences.length; i++ )
			{
				if ( helper.sprite_sequences.indexOf( sequences[i] ) < 0 )
				{
					helper.sprite_sequences.push( sequences[i] );
				}
			}
			
			var str:String = "<TextureAtlas imagePath=''>";
			var prefix:String = "";
			for ( i = 0; i < len; i++ )
			{
				prefix += "a";
				str += "<SubTexture name='" + names[i] + "_" + prefix + "' x='" + rects[i].x + "' y='" + rects[i].y + "' width='" + rects[i].width + "' height='" + rects[i].height + "' />";
				if ( helper.sequences.indexOf(names[i]) < 0 ) helper.sequences.push( names[i] );
			}
			str += "</TextureAtlas>";
			helper.sparrow_xml = new XML(str);
			
			return helper;
			
		}
		
		/**
		 * Checks that a vector of rectangles when greedy arranged will conform to the Context3DProfile defined maximum texture size
		 * @param	rects	A vector of Rectangles
		 * @param	context3Dprofile	The profile to check against. If left as an empty string (default) it will grab the currently used Starling profile.
		 * @return	True is the rectangle arrangement conforms. False if it does not.
		 */
		
		public static function checkArrangeSize( rects:Vector.<Rectangle>, context3Dprofile:String = "" ):Boolean
		{
			var arr:Array = greedyArrange(rects);
			
			if ( !context3Dprofile.length )
			{
				context3Dprofile = Starling.current.profile;
			}
			
			if ( context3Dprofile == Context3DProfile.BASELINE || context3Dprofile == Context3DProfile.BASELINE_CONSTRAINED )
			{
				var max_texture_size:int = 2048;
			}
			else
			{
				max_texture_size = 4096;
			}
			
			return ( arr[0] <= max_texture_size && arr[1] <= max_texture_size );
		}
		
		/**
		 * Takes an array of sprite sequences and returns a 3D Array representing the best possible sequential arrangement for the current device Context3DProfile setting
		 * @param	sprite_sequences	An array of SpriteSequence objects. Indexing order is maintained in the resulting arrangement.
		 * @return	A 3D Array of SpriteSequence objects.
		 */
		
		public static function optimizeListForDevice( sprite_sequences:Array ):Array
		{
			if ( !sprite_sequences || !sprite_sequences.length ) return null;
			
			var len:int = sprite_sequences.length;
			var rects:Vector.<Rectangle> = new Vector.<Rectangle>;
			var arr:Array = new Array();
			arr.push( new Array() );
			
			for ( var i:int = 0; i < len; i++ )
			{
				var ss:SpriteSequence = sprite_sequences[i];
				var ss_len:int = ss.sprites.length;
				for ( var j:int = 0; j < ss_len; j++ )
				{
					rects.push( new Rectangle(0, 0, ss.sprites[j].width, ss.sprites[j].height) );
				}
				
				var fits:Boolean = checkArrangeSize( rects );
				
				if ( !fits )
				{
					while ( rects.length ) rects.shift();
					
					for ( var j:int = 0; j < ss_len; j++ )
					{
						rects.push( new Rectangle(0, 0, ss.sprites[j].width, ss.sprites[j].height) );
					}
					arr.push( [ss] );
				}
				else
				{
					arr[arr.length - 1].push(ss);
				}
			}
			
			return arr;
		}
	}

}